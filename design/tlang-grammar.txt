
operator and expression
++a, --a -(++a) +(++a)
a += 3
3(5+4) 3x+4y

合一: a :=: b;
不能合一: a :\:

谓词: 加感叹号，只是个习惯而已
a =! b a >! b

赋值
------
a = 1;   
a, b = list1
a, b = 1, 2
a = b = 1 #串连赋值
a, b := a+b, a+b # 串行赋值

分支
if a>1 do: print 1
if a>1 print 1
if a>1 do: print 1; else: print 2

if a>1 do: print 1
else: print 2

if a>1: print 1
else if a>2: print 2
else: print 3

if a>1: print 1; else [ if a>2: print2; else: print 3 ]

情况
case x:
  1: print 1
  2: print 2
  3: print 3

case x:
  1,2: print 1
  3,4: print 2
  else: print 3

case x, y:
  (1, 2): print 1
  (3, 4): print 2

case x of 1: print 1; of 2: print 2; else: print 3

块
block a: print 1; print 2; if a>1: break a; print 3 

循环
--------
loop: print x

loop: 
  print x

loop 3 times: print x

loop: print x until x=5

loop: print x while x=5

while x=5 loop: print x

unless x=5 loop: print x

loop/a: print 1; exit a with 1 

loop: loop: print a; exit 2 layer with 1

loop: [ loop: print 1; until 1 ]; exit 

for i=0 till i<5 by i++: print i; next for

for i from 10 down to 0: print i
for i from 10 down to 0 by 2: print i
for i from 0 to 10 by 2: print i
 
异常：

try: print a; except: print b; finally: print c

catch a: print 1; throw: a with 1

try: print a; always: print 1

pytry: print; except Error, e: print; finally: print c

函数, 宏

let, rec let
where, rec where

let a=1, b=2 do print a 
let a=1; b=2 do print a

rec let a=1, b=2 do print a

do print a  rec where a=1, b=2

memo@ : memo the result after excute command. 

// default no arguments, same as fun a(): print
fun a: print a  // default :=
fun a:= print a // replace definition

fun a:^ print a  // insert before

fun a:! print a // append after

fun b(x y): print 2

fun b (x, y): print 2
      (i):^ print 1
      (1,2):= print 3

fun b:= (x, y): print 2
        (i):^ print 2
        (): print 3     

fun (x): print 1; print 2
    (x, y): print 1

// remove definitions

del fun a

del fun a/3

del fun a head: (x, y), (x) 

macro: same grammar with function.

回引号
----------
'f(x)

`f(,x)

`f(,@x)

导入
-------------

use a

use a.b

use a/b

use a/b/c

use a/*

use a/*b

use a/b*

use a/b*e

use a.(b as x, c as y)
use a/(b, c)

use a/* if test(*)

动态语法
--------

write(x):
  'write'; expression(x); print x

statement(x):! write(x)

binary(x, add):! operator('-', add,  precedence(grammar.operator.add))

statement:
  expression staement
  let
  recursive let
  where
  case
  loop
  while
  fun
  macro
  block
  label 
  break # break label with 5; break 2 levels with 5; break 2 levels loop/times; break; break with 5
  return # return 5
  redo # redo label; redo 2 levels; redo 2 levels loop/times

expression: 
  number
  string
  comma separated
  unary
  binary
  ternary
  ()

  list [...]
  tuple #[]
  dictionary #{}
  function call
  attribute access  

number: integer, float

string: "...", """  """
string template:  %()s, %()r, %()d, %name, %()/s, %a/b, %a/b, %a/n

comment = function() [ // + any(char(_))+eol] #到行尾
                     [ /. + any(char_)) + ./] # embeddable
 

while 1 do:
    while 1 do:
        while 1 do:
            print 1

while 1 do:
   while 1 do:
       while 1 
do:
   print 1
   print 2

