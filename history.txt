details of history:

2011-11-14 12:25:50 : 
change the __repr__ of Var by mistake when adding NullVar, fix it.

2011-11-14 11:57:04 : 
fix the warnings: GeneratorExit ignored
try: 
  ...
  yield ...
except: ... # except KeyError, or any specific exception class.

2011-11-14 11:30:19 
1+1 => 2

2011-11-14 10:27:43 : 
bug: in make_rules, the index of arity2signatures is wrong
  for i, rule in enumerate(rules):
  ...
for signature in rule_head_signatures(head):
      arity_signature = arity2signatures.setdefault(arity, {})
      arity_signature.setdefault(signature, pyset()).add(i) #fix: i ==>  len(arity2rules[arity]-1

2011-11-13 15:09:45 : 
git* add NullVar
add NullVar, which do nothing and always succeed when unify.

2011-11-13 14:56:41 : 
add NullVar, which do nothing when unify.

-------------------------
2011-11-13 14:55:37 
organize the type hierachy of statement and expression

---------------
2011-11-13 11:40:26 : 
git * dinpy/samples become tests
dinpy/samples: hello.py, interactive.py, parse_interactive.py, sample.py become tests in testdinpy.py

2011-11-13 11:36:38
dinpy/samples become tests

-----------------------
2011-11-13 11:15:20 
git* fix the bug in passing DummyVar as function's arguments

bug with closure var and is_, which is from passing DummyVar as function's arguments, see previous commit message for more informations.
solution: pass BuiltinPredicate by DummarVar itself, pass BuiltinFunction by value of DummyVar.

2011-11-13 10:35:22: 
* figthing with the bug in passing DummyVar as function's arguments

bug with closure var and is_?
solution: don't pass value by DummyVar, some(statement(_stmt), _stmt, stmt_list)
    if isinstance(exps[0] , DummyVar):
      yield argument_cont, exps[0]
    else: yield solver.cont(exps[0], argument_cont), True
now another bug: DummyVar bring same value out every time?
  def test_Case1(self):
    x = preparse(v.x)
    eq_(preparse(case(x).of(1)[prin(1)].of(2,3)[prin(4)].els[prin(5)]),
        special.CaseForm(x,{1:(prin(1),), 2:(prin(4),), 3:(prin(4),)}, (prin(5),)))

2011-11-13 10:22:54 : 
Why do DummyVar bring same value out every time?

2011-11-13 09:52:44
figthing with the bug in passing DummyVar as function's arguments . 

-----------------------------------------------
15:01 2011-11-12
bug fix: do not restore solver.parse_state when return from rule.apply
      yield solver.exps_cont(self.body, rule_done_cont), True
    solver.env = caller_env 
    solver.call_path = call_path
    solver.parse_state = parse_state  # <<< add this line to fix it.  

13:34 2011-11-12
find the way to debug dao rules by prin

-------------------------
12:12 2011-11-12
what's wrong with closure var and is_?
don't pass value by DummyVar, some(statement(_stmt), _stmt, stmt_list)
    if isinstance(exps[0] , DummyVar):
      yield argument_cont, exps[0]
    else: yield solver.cont(exps[0], argument_cont), True
21:29 2011-11-12
conflict with dinpy: testdinpy, test_doc_interactive
  getattr(__._)+assign(vv.x, getvar(__._)

@builtin.function('getvar')
def getvar(name, klass=Var): 
  return varcache(name, klass)
---------------
11:18 2011-11-12
container.py: startswith, endswith

-----------------
11:03 2011-11-12
container.py
length, concat: deref->getvalue

-----------------------------
10:07 2011-11-12
classic grammar: assign statement

-------------------------
9:31 2011-11-12
special.set
  yield cont, value ->
  yield cont, self.var 
  restore -> yield cont, value, do not need to destroy some tests.

---------------
9:26 2011-11-12
git commit * bug fix: getvalue of recursive object
when getvalue of recursive object, infinite recursive call to getvalue, fix it by using memo.

-----------
8:34 2011-11-12
* trivial tests for t language
classic and sexpression for t language, pass some trivial tests.

===================================================================================================
----------------------------
What's new in dao 0.7.4?
----------------------------

*Release date:  2011-11-10

* new in code:
  * quasiquote, unquote, unquote_slicing is implemented.
  * directly evaluate sexpression in solver
  * some builtins for define, set and get global, outer and local var
  * lisp style macro: expand and eval on UserMacro

----------------------------
What's new in dao 0.7.3?
----------------------------

*Release date:  2011-11-4

* new in code:
  * memo the result of after running command to suppoort left recursive and to speedup.
  * use signatures of rule head to cut down the rules to unify with.
  * samples\sexpression.py pass all tests in dao\tests\testsexpression.py.
  * rename builtin.function2 to builtin.predicate

* chinese document is almost finished: 
  * add document about samples\sexpression.py in chinese document
  * other modification and update in document.


----------------------------
What's new in dao 0.7.2?
----------------------------

*Release date:  2011-10-27

* new in code:
  * refactor findall, call, once
  * fix a bug that prevent some backtracking in optional
  * fix the bug caused by getvalue/setvalue.
     the bug masks the internal generated variable for function argumnet when return and causes error in some situations.

* chinese document is almost finished: 
  * new chapter: function, macro
  * more about logic command in document(zh)

----------------------------
What's new in dao 0.7.1
----------------------------

*Release date:  2011-10-28

fix bugs
  * a big bug in 0.7.0 in assign when dinpy run in interactive mode is fixed
some new builtins in builtins/term.py


----------------------------
What's new in dao 0.7.0?
----------------------------

*Release date:  2011-10-26

    the code is rewriten completely by the improved techinque which is used by yieldprolog(http://yieldprolog.sourceforge.net). Yield statement is used to implement unify and backctracking of logic engine, besides, all continuations become functions, by remove class definition. So dao have a great speed up in its run now, and I believe that it can be used in real project. 
    A language dinpy that uses dao's solver as the core is implemented. Dinpy is embeded in python, and dinpy have the features that both lisp and prolog provided.
    Some documents about dao and dinpy are written.

----------------------------
What's new in dao 0.6.2? 
----------------------------

environment(env), substition(subst) and trail play together(which was called heap before). module was reimplemented by ModuleEnvironment?. new builtin: setvalue, catch, throw in lisp style, old catch and throw become try, raise. block and return-from, unwind-protect.

----------------------------
What's new in dao 0.6.1? 
----------------------------

Release date: 2011.3.18

Grand unified theory in programming language is realized: Code is unified with data; grammar is unified with program; logic is unified with function; compiling is unified with running.

add some absent builtins: repeat(control.py), throw, catch(in exception.py), standard compare(in unify.py, no standard_cmp is coded, so they is commented). macro which return macro can implement so called parameterized rules. see TestParameterize? in builtins\tests\testparser.py . tests about dynamic grammar modify interface to parse. don't use class Streamer, only maintain a member called stream in evaluator. don't give any assumption on the content of the stream. builtins in matchterm.py have no demand on the interface of stream. Stream and Line Stream are comptible with terminal.py. Other terminals can be write based on the interface of class Stream in builtins\parser.py. Other

terminals aware of line can be write based on the class LineStream in builins\lineparserpy.
If needed, other streams and terminals can be added. some tests(dao\tests\testsexpression\Test_eval_while_parsing) is added to demo the power of the dynamics of the parsing.

----------------------------
What's new in dao 0.6.0? 
----------------------------

Release date: 2011-3-14

core

a lisp style evaluator is implemented, which can eval expressions which is a hybrid of lisp forms and prolog terms.
means that dao can eval rules with logic variables.
function is a super concept of lambda, because function can be defined by mutilple rules with logic varialbes in caller form and rule body.
macro is similar to function except that macro is called with its arguments which are not evaluated beforhand.
the evaluator and parser is integrated. so you can use the evaluator as a parser and includes forms like (eval parsedResult) in the parse rules.
can parse and eval lisp sexpression.
implemented by double continuation include success cont(scont) and fail cont(fcont), borrowed and modified heavily from pypy prolog
the evaluator loop is like lisp's metacirlar eval method.

builtins

prolog builtins
logic control, unify, type, metacall, findall, format, atom, term, arithpred
for parsing
parser, terminal(char, number, letter, ...), matchterm(optional, any, some, times, seplist, ...)
arithmetic operation
callcc
module

----------------------------
What's new in 0.1.3 
----------------------------

# Released date: 2007.6


1 precedence of the elements and rules is processed correctly.

2 Condition, which can be used to exclude ambiguous parsed result in Kleene star, E+E|E*E, if-then-else and the like, can be put in the rule.

3 Adding and removing rule dynamically is permitted and the features of elements are computed according to the revision of the grammar.

4 Multiply,Division and Cons are added to termlib.py.

----------------------------
What's new in 0.1.2? 
----------------------------

Simpler code and run faster

Many things is cut from the source, like ascenders, augmentGrammar, but the parser can run faster now( profileParse.py run in 0.99s).

Precedency is processed and pass all tests.

----------------------------
What's new in 0.1.1?
----------------------------

# Released date: 2007.5

Big refactor of the code: remove many stuffs: such as ascenderRuleses, descenderRuleses, firstSegments, lastSegments, beforeSegments, followSegments, MinimizeSegments?, fitFollowBefore etc. All tests which is neccessary to parse passed, including precedence tests. The program runs faster now.
