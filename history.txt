details of history:


2013-1-17
fix a bug: should restore the parse_state and bindings after cut or cut_or
save the parse_state and bindings, and restore them in the continuation of solver.cut_cont and solver.cut_or_cont
bug: del bindings[_] # raise KeyError if _ is DummyVar
fix: try-except in solvebase.py Bindings.__delitem__
LogicVar.cps_convert: cont(il.LogicVar(x))
  modifying the code in LogicVar.cps_convert to
  cont(il.LogicVar(x)), use getvalue(x) in expression instead.

2013-1-15
  matcher.py: any, lazy_any, greedy_any

2012-1-13
register_function in compilebase.py

teminal.py:
  char_on_predicate, string_on_predicate
from terminal import char_on_predicate, digit, one_to_nine
from terminal import lowcase, uppercase, letter, underline_letter, underline_letter_digit
from terminal import tabspace, whitespace
from terminal import string_on_predicate0, digits0, one_to_nines0
from terminal import lowcases0, uppercases0, letters0, underline_letters0, underline_letter_digits0
from terminal import tabspaces0, whitespaces0
from terminal import string_on_predicate1, digits1, one_to_nines1
from terminal import lowcases1, uppercases1, letters1, underline_letters1, underline_letter_digits1
from terminal import tabspaces1, whitespaces1
from terminal import string_on_predicate

2013-1-12
il.Atom -> ConstAtom + MutableAtom(include List, Dict)
tests on catch broken, for not optimzation of List of catch_cont_map[tag], fixed.
arith.py: eq, ne, le, ge, lt, gt, between.
term.py: getvalue, deference, isinteger, isfloat, isnumber, isstr, istuple, islist, isdict

2013-1-11
more io builtinsï¼šconcat, format, open_file, close_file, read, readline, readlines, write
repeat: wrong implementation
first_p: tested with findall
is_
findall(goal, template, bag): old test passed.

---------------------
2012-12-8
what do I need in analysing?
# var assign and reference
# io effects
# lamda's local vars: not in upper level and not in lower level

2012-12-7
python files: 95, lines: 13198, characters: 432830
text files: 15, lines: 2186, characters: 88464
rest files: 38, lines: 2753, characters: 108491

code cleanup

OptimizationData, CodeGenerator is merged into Compiler, Both the parameter "data" of optimize_analysis and optimize, "coder" of to_code become "compiler".
remove assign_convert.

2012-12-6
optimize catch/throw, block/break/continue, cut

2012-12-4
more tests on optimization completed

more tests on optimization completed, except the tests below:
bug left:
  TestCut: all passed except testCut6
All tests which passed before optimization still pass now.

2012-12-3
optimization almost completed
bug left: 
  findall: only do first choice.
  assert_raises(NoSolution, eval, begin(unify(Lx, 1), unify(Lx,2))) # KeyError: 1
  eq_(eval(begin(set_text('a'), char('a'), eoi)), True) #Exception: AssertionError: None != True
  TestCut: all failed except testCut1
  eq_(eval(let([(f, rules([[x], add(x, x)]))], f(f(1)))), 4)  #Exception: KeyError: 2
  eq_(eval(letrec([(f, rules([[1], 1],[[x],f(sub(x,1))]))], f(2))), 1) #Exception: KeyError: 2
  assert_raises(NoSolution, eval, parse_text(rule, 'a b')) #Exception: UnboundLocalError: local variable 'fc11' referenced before assignment
  eq_(eval(begin(set_text('aaa'), any(char('a')), eoi)), True) #Exception: RuntimeError: maximum recursion depth exceeded in cmp

2012-12-1
add MacroVar, RecursiveFunctionVar, RecureiveMacroVar in builtins\define.py
il.RecursiveFunctionVar becomes il.RecursiveVar
debug loop by block, a bug in optimizing assign was found:
set initial value before block: i = 1
decrement in block: i = i-1
should find vars like above in block beforehand.

2012-11-30
optimization on letrec, some tests passed
A new idea has not been implemented: record the informations of var in let/letrec, and remove the unnecessary IsMacroFunction test.

letrec tag RecursiveFunctionVar, don't remove the assigns from inter language, record the call path in Apply.optimizations on RecursiveFunctionVar.

2012-11-29
more optimization finished
more optimization finished, include assign, deref, len, in, getitem, rules_function, if_, IsMacroFunction, etc.

python files: 95, lines: 12947, characters: 429890
text files: 15, lines: 2137, characters: 86393
rest files: 38, lines: 2753, characters: 108491

2012-11-28
fix bug:
use tuple as macro arguments' class, which stop optimizing and pythonize_exp to te arguments. so
if any statement is included in the arguments, syntax error happens in the compiled code.
fix: new class MacroArgs for macro arguments.

remove optimize, exp.optimize_once becomes exp.optimize

2012-11-27
macro implmented

2012-11-26
new gread idea about eval_ and macro:
wrap quoted or quasiquoted expression with ExpressionWithCode, 
where ExpressionWithCode contains the code generated by the expression.
eval_ with this idea has been implemented at 10'oclock pm.
bug: test_unquote_slice: Exception: TypeError: iteration over non-sequence
  ExpressionWithCode
  if isinstance(a0, UnquoteSplice): 
    result += a0.item

2012-11-25
fighting with macro and eval_, find trouble in current implementation
a new great idea occurs at night.

2012-11-24
split builtins\special.py to define.py+special.py

fix bug: 
  when calling function rules directly, missed evaluating the arguments.
fix bug: 
  unify(x, y), y.interlang() was called too early, so LogicVar become il.LogicVar, 
  and LogicVar.cps_convert disappeared.

big bug:
  eval_ is not correct except quote.
  fix: 
    exp.cps_convert(compiler, cont)..cps_convert(compiler, cont) -->
    exp.cps_convert(compiler, il.clamda(v, cont(eval_exp(compiler, v))))

2012-11-23
quasiquote/backquote

DummyVar, println
settext -> set_text
set_sequence, parse, parse_sequence, eoi, boi, step, skip, goto, next_element/next_char, position, left, subtext, subsequence

process inserting yield and return better.

word, identifier, integer, literal

2012-11-22
rules, cut, cut_or finished 

fix bug:
def callcc(compiler, cont, function):
  ...
  ### v = compiler.new_var(il.Var(v0) --->
  v = compiler.new_var(v0)

fix bug: wrong global declaration of local variables
  # add class LocalVar as subclass of il.Var

restart at 2012.10
===========================================================

2011-11-28 14:58:36 
start typer

2011-11-28 12:30:01 
some demostation of compiled code in compiler\compiled folder

2011-11-28 12:30:38 
find a schema for shorten the binding chain, do not shorten when dao.term.getvalue if correct. 
shorten it when unify or in builtin instead.??? something must be wrong with this.

2011-11-27 22:30:37 
git* catch, throw, not finished completely
start on function

2011-11-27 18:05:37 
BlockCont, block, exit_block, continue_block

2011-11-27 16:05:34 
rename cont.cont to cont.succ

2011-11-27 14:20:07 
generate code from the root cont 

2011-11-27 12:42:45 
thinking about builtin.matcher: parallel, interesting code expansion

2011-11-27 11:25:22 
thinking about builtin.matcher: char and optional for compiler

2011-11-26 14:20:03 
compile_to_cont: sub(1,add(2,3)) pass tests.

2011-08-23 10:46:12 
compile_to_cont: add(1,2)

2011-11-25 17:26:31 
git* some parser builtins: char, nullword, optional, parse_sequence
tips: 
  char:
   unify(... solver.---env---
  optional:
    def fcont(value, solver):
        ....
	!!! +++ else: solver.scont = old_fcont
    
2011-11-25 17:05:33 
git* another cut: CutOr, only cut Or
no tests given

2011-11-25 16:38:59 
git* redo cut feature use method similar to pypy prolog; tests passed.
def Cut(solver):
  def fcont(value, solver):
     while...p:
      try: cont.cut
      except: 
        cont = cont.cont
        continue
      solver.scont = cont.cont
      return
  in RuleList.apply:
    def rules_cut_cont(value, solver):
      solver.scont = old_fcont
    rules_cut_cont.cut = True

2011-11-25 16:18:06 
the previous implemention of cut is wrong completely
remember the cut in pypyprolog

2011-11-25 14:46:50 
git* prolog'cut in double continuations

modify for cut feature in two continuations, passed tests!
only spended 8 minites: first method: solver.cut = False
builtin 
def Cut(solver):
  solver.cut = True

another 8 minitues: 
  solver.cut = False/True 
--> 
  solver.cut_level = 0 # 1, 2

2011-11-25 14:32:22 
cut features pass tests! only spended 8 minites!

2011-11-25 14:25:01 
modify for cut feature in two continuations

2011-11-25 14:08:57 
git* builtins\quasiquote.py and container.py for two continuations

2011-11-25 14:02:01 
builtins\quasiquote.py for two conitinuations passed tests

2011-11-25 13:39:21 
modify builtins\quasiquote.py for two conitinuations

2011-11-25 13:35:41 
modify builtins\container.py for two conitinuations
pass tests

2011-11-25 11:26:04 
modify builtins\container.py for two continuations
remove deprecated SubSequenceUEntitySubContinuation, SubSequenceVarAfterContinuation, SubSequenceElseContinuation
In subsequence:
  if ...: return 
  --->
    if...: 
      solver.scont = solver.fcont
      return

        for _ in unify...:
          for _ in unify...:
            yield cont, ...
   ---> return unify ... and unify ...

2011-11-25 11:15:48 
fix bug: Rule.apply
      def fcont(value, solver):
          ...
          solver.|fcont ---> scont| = old_fcont

2011-11-25 10:59:25 
modify builtins\term.py for two continuations

2011-11-25 10:21:48 
git* fix two bugs in RuleList.apply and callcc

2011-11-25 10:16:50 
fix bug in callcc: AttributeError cont.order
def callcc(solver, fun):
  ''' call with current continuation '''
  solver.scont = solver.cont((fun, ContinuationFunction(solver.|cont ---> scont|, '', '', False)), solver.scont)
find the reason by using compare working copy with older version

2011-11-25 09:46:03 
fix bug: in RuleList.apply:
  +++ cont = solver.scont
      ...
      def fcont(value, solver):
  +++    solver.scont = cont
        ...

2011-11-25 09:10:03 
git* builtins\control.py, builtins\arith.py pass tests, refactor builtin's signature to remove argument cont

builtins\control.py, builtins\arith.py is modified for double continuations
refactor builtin's signature, the_builtin(solver, cont, ...) becomes the_builtin.py(solver, ...)
unify, unify_list is ready for double continuations
fix a bug in some fconts: solver.scont = old_fcont; instead of solver.fcont = old_fcont

2011-11-25 09:30:10 
fix bug: def fcont and cont.order

2011-11-24 11:24:00 
git* all tests in testeval.py except testcut passed.

pytry. eachform, loop form pass tests.

2011-11-24 20:10 
git* use double continuations, pass many tests

use double continuations, pass many tests: integer, begin, quote, set, eval_, if_, let, letr, function, builtin.function, builtin.predicate, and so on.

2011-11-24 07:21:54 
two continuations

2011-11-24 15:21:45 
compiler

2011-11-21 10:11:28 
block comment builtin

2011-11-17 10:35:34 
coding for function, macro definition and remove
syntax error is cheched, now debuging the grammar.

2011-11-16 20:10:48 
git* block, redo, break, pass, error, pad_tabspaces, tabspaces_if_needed

block statement, redo statement
break statement
pass statement

builtin error for debug
builtin format

2011-11-16 20:04:28 
git* block statement, redo statement

2011-11-16 19:35:58 
break statement

2011-11-16 15:37:12 
pass statement

2011-11-16 19:04:58 
builtin error for debug
 
2011-11-16 15:22:43 
git* loop-while tests failed for the bug below, passed after fix it:
bug fix: 
	--- solver = env.extend({}) --- 
        ===>
        solver.env = env
        env.bindings = old_bindings.copy()
        --- #env.bindings.update(memo) ---
        for _ in unify_list(vals, result_head, solver.env):
          yield c, value
        env.bindings = old_bindings
 
2011-11-16 13:35:46 
debug trick: use fail to stop at som place.

2011-11-16 09:52:06 
pass all tests after add and modifier terminals
 
2011-11-16 08:47:44 
git* more frequent used terminals relating to char and space
chs0, chs, 
space, tab, tabspace, whitespace, newline, 
spaces0, tabs0, tabspaces0, whitespaces0, newlines0, 
spaces, tabs, tabspaces, whitespaces, newlines.
 
2011-11-16 08:07:11 
add terminal char2, ch

2011-11-16 22:26:10 
git* loop-until statement

loop-until statement
modify:
  get_label(solver), 
  push_label(solver, control_struct_type, label), 
  pop_label(solver, control_struct_type)
  identifier: don't use keyword as identifier

2011-11-16 22:21:53 
loop-until statement

2011-11-16 17:27:50 
git* loop-times statement
 
2011-11-16 14:35:01 
case statement

2011-11-16 12:06:21 
if-elif-else statement

2011-11-16 09:31:29 
git* let statement

2011-11-16 09:00:29 
print statement

2011-11-16 21:18:15 
git* two whole days, just for miss information in left recursive memo!!!
  sign_state2cont.insert(i, (solver.call_path, cont, solver.env, ***values***))
        for _ in unify_list(vals, result_head, solver.env):

2011-11-16 14:50:15 
bug fix:
Var:: deref(self, env):

    next = env.bindings.get(envValue, None)
    if next is None: return envValue
    if next is self: return next
    result = deref(next, env)
====>
    envValue = env[self]
    if envValue is self: return envValue
    if not isinstance(envValue, Var): return envValue
    return deref(envValue, env)

2011-11-16 10:30:07 
index RuleHeadCopyVar correctly
  class_index = 1
  def __init__(self, var):
    self.name = var.name
    self.index = RuleHeadCopyVar.class_index
    RuleHeadCopyVar.class_index += 1

2011-11-16 10:02:05 
remove Var.new()

2011-11-16 08:18:13 
yesterday, 1+2*3 parse finished, but return no result with var in env.

2011-11-15 20:41:51 
bug fix: not_p restore solver.parse_state when fail.
def not_p(solver, call):
  call = deref(call, solver.env)
  parse_state = solver.parse_state
  for c, x in solver.exp_run_cont(call, cont):
    solver.parse_state = parse_state
    return
  #solver.parse_state = parse_state
  yield cont, True

2011-11-15 20:23:24 
     else: 
++       *** if len(path)==len(solver.call_path) and cont.cont_order<c.order: *** # 
          break 

2011-11-15 20:23:24 
bug fix: save env in memo sign_state2cont.insert(i, (solver.call_path, cont, **solver.env**))
 
2011-11-15 16:16:18 
bug fix: classic.py: identifier use terminal.uLetterdigitString by mistake. add termial.identifier.

2011-11-15 14:34:30 
git* bug fix: memo result don't memo fail of rules.
    if len(sign_state2cont)==1: 
      for c, v in self.apply(solver, memo_result_cont, values, signatures):
        yield c, v
      if not have_result[0]:   # update 2011-11-15 14:35:26 
        solver.sign_state2results[sign_state] = []

2011-11-15 12:45:23 
t\operator.py bad mistake: solver.parse_state mispelled: solver.parser_state

2011-11-14 12:25:50 : 
git* change the __repr__ of Var by mistake when adding NullVar, fix it.

2011-11-14 11:57:04 : 
fix the warnings: GeneratorExit ignored
try: 
  ...
  yield ...
except: ... # except KeyError, or any specific exception class.

2011-11-14 11:30:19 
1+1 => 2

2011-11-14 10:27:43 : 
bug: in make_rules, the index of arity2signatures is wrong
  for i, rule in enumerate(rules):
  ...
for signature in rule_head_signatures(head):
      arity_signature = arity2signatures.setdefault(arity, {})
      arity_signature.setdefault(signature, pyset()).add(i) #fix: i ==>  len(arity2rules[arity]-1

2011-11-13 15:09:45 : 
git* add NullVar
add NullVar, which do nothing and always succeed when unify.

2011-11-13 14:56:41 : 
add NullVar, which do nothing when unify.

-------------------------
2011-11-13 14:55:37 
organize the type hierachy of statement and expression

---------------
2011-11-13 11:40:26 : 
git * dinpy/samples become tests
dinpy/samples: hello.py, interactive.py, parse_interactive.py, sample.py become tests in testdinpy.py

2011-11-13 11:36:38
dinpy/samples become tests

-----------------------
2011-11-13 11:15:20 
git* fix the bug in passing DummyVar as function's arguments

bug with closure var and is_, which is from passing DummyVar as function's arguments, see previous commit message for more informations.
solution: pass BuiltinPredicate by DummarVar itself, pass BuiltinFunction by value of DummyVar.

2011-11-13 10:35:22: 
* figthing with the bug in passing DummyVar as function's arguments

bug with closure var and is_?
solution: don't pass value by DummyVar, some(statement(_stmt), _stmt, stmt_list)
    if isinstance(exps[0] , DummyVar):
      yield argument_cont, exps[0]
    else: yield solver.cont(exps[0], argument_cont), True
now another bug: DummyVar bring same value out every time?
  def test_Case1(self):
    x = preparse(v.x)
    eq_(preparse(case(x).of(1)[prin(1)].of(2,3)[prin(4)].els[prin(5)]),
        special.CaseForm(x,{1:(prin(1),), 2:(prin(4),), 3:(prin(4),)}, (prin(5),)))

2011-11-13 10:22:54 : 
Why do DummyVar bring same value out every time?

2011-11-13 09:52:44
figthing with the bug in passing DummyVar as function's arguments . 

-----------------------------------------------
15:01 2011-11-12
bug fix: do not restore solver.parse_state when return from rule.apply
      yield solver.exps_cont(self.body, rule_done_cont), True
    solver.env = caller_env 
    solver.call_path = call_path
    solver.parse_state = parse_state  # <<< add this line to fix it.  

13:34 2011-11-12
find the way to debug dao rules by prin

-------------------------
12:12 2011-11-12
what's wrong with closure var and is_?
don't pass value by DummyVar, some(statement(_stmt), _stmt, stmt_list)
    if isinstance(exps[0] , DummyVar):
      yield argument_cont, exps[0]
    else: yield solver.cont(exps[0], argument_cont), True
21:29 2011-11-12
conflict with dinpy: testdinpy, test_doc_interactive
  getattr(__._)+assign(vv.x, getvar(__._)

@builtin.function('getvar')
def getvar(name, klass=Var): 
  return varcache(name, klass)
---------------
11:18 2011-11-12
container.py: startswith, endswith

-----------------
11:03 2011-11-12
container.py
length, concat: deref->getvalue

-----------------------------
10:07 2011-11-12
classic grammar: assign statement

-------------------------
9:31 2011-11-12
special.set
  yield cont, value ->
  yield cont, self.var 
  restore -> yield cont, value, do not need to destroy some tests.

---------------
9:26 2011-11-12
git commit * bug fix: getvalue of recursive object
when getvalue of recursive object, infinite recursive call to getvalue, fix it by using memo.

-----------
8:34 2011-11-12
* trivial tests for t language
classic and sexpression for t language, pass some trivial tests.

===================================================================================================
----------------------------
What's new in dao 0.7.4?
----------------------------

*Release date:  2011-11-10

* new in code:
  * quasiquote, unquote, unquote_slicing is implemented.
  * directly evaluate sexpression in solver
  * some builtins for define, set and get global, outer and local var
  * lisp style macro: expand and eval on UserMacro

----------------------------
What's new in dao 0.7.3?
----------------------------

*Release date:  2011-11-4

* new in code:
  * memo the result of after running command to suppoort left recursive and to speedup.
  * use signatures of rule head to cut down the rules to unify with.
  * samples\sexpression.py pass all tests in dao\tests\testsexpression.py.
  * rename builtin.function2 to builtin.predicate

* chinese document is almost finished: 
  * add document about samples\sexpression.py in chinese document
  * other modification and update in document.


----------------------------
What's new in dao 0.7.2?
----------------------------

*Release date:  2011-10-27

* new in code:
  * refactor findall, call, once
  * fix a bug that prevent some backtracking in optional
  * fix the bug caused by getvalue/setvalue.
     the bug masks the internal generated variable for function argumnet when return and causes error in some situations.

* chinese document is almost finished: 
  * new chapter: function, macro
  * more about logic command in document(zh)

----------------------------
What's new in dao 0.7.1
----------------------------

*Release date:  2011-10-28

fix bugs
  * a big bug in 0.7.0 in assign when dinpy run in interactive mode is fixed
some new builtins in builtins/term.py


----------------------------
What's new in dao 0.7.0?
----------------------------

*Release date:  2011-10-26

    the code is rewriten completely by the improved techinque which is used by yieldprolog(http://yieldprolog.sourceforge.net). Yield statement is used to implement unify and backctracking of logic engine, besides, all continuations become functions, by remove class definition. So dao have a great speed up in its run now, and I believe that it can be used in real project. 
    A language dinpy that uses dao's solver as the core is implemented. Dinpy is embeded in python, and dinpy have the features that both lisp and prolog provided.
    Some documents about dao and dinpy are written.

----------------------------
What's new in dao 0.6.2? 
----------------------------

environment(env), substition(subst) and trail play together(which was called heap before). module was reimplemented by ModuleEnvironment?. new builtin: setvalue, catch, throw in lisp style, old catch and throw become try, raise. block and return-from, unwind-protect.

----------------------------
What's new in dao 0.6.1? 
----------------------------

Release date: 2011.3.18

Grand unified theory in programming language is realized: Code is unified with data; grammar is unified with program; logic is unified with function; compiling is unified with running.

add some absent builtins: repeat(control.py), throw, catch(in exception.py), standard compare(in unify.py, no standard_cmp is coded, so they is commented). macro which return macro can implement so called parameterized rules. see TestParameterize? in builtins\tests\testparser.py . tests about dynamic grammar modify interface to parse. don't use class Streamer, only maintain a member called stream in evaluator. don't give any assumption on the content of the stream. builtins in matchterm.py have no demand on the interface of stream. Stream and Line Stream are comptible with terminal.py. Other terminals can be write based on the interface of class Stream in builtins\parser.py. Other

terminals aware of line can be write based on the class LineStream in builins\lineparserpy.
If needed, other streams and terminals can be added. some tests(dao\tests\testsexpression\Test_eval_while_parsing) is added to demo the power of the dynamics of the parsing.

----------------------------
What's new in dao 0.6.0? 
----------------------------

Release date: 2011-3-14

core

a lisp style evaluator is implemented, which can eval expressions which is a hybrid of lisp forms and prolog terms.
means that dao can eval rules with logic variables.
function is a super concept of lambda, because function can be defined by mutilple rules with logic varialbes in caller form and rule body.
macro is similar to function except that macro is called with its arguments which are not evaluated beforhand.
the evaluator and parser is integrated. so you can use the evaluator as a parser and includes forms like (eval parsedResult) in the parse rules.
can parse and eval lisp sexpression.
implemented by double continuation include success cont(scont) and fail cont(fcont), borrowed and modified heavily from pypy prolog
the evaluator loop is like lisp's metacirlar eval method.

builtins

prolog builtins
logic control, unify, type, metacall, findall, format, atom, term, arithpred
for parsing
parser, terminal(char, number, letter, ...), matchterm(optional, any, some, times, seplist, ...)
arithmetic operation
callcc
module

----------------------------
What's new in 0.1.3 
----------------------------

# Released date: 2007.6


1 precedence of the elements and rules is processed correctly.

2 Condition, which can be used to exclude ambiguous parsed result in Kleene star, E+E|E*E, if-then-else and the like, can be put in the rule.

3 Adding and removing rule dynamically is permitted and the features of elements are computed according to the revision of the grammar.

4 Multiply,Division and Cons are added to termlib.py.

----------------------------
What's new in 0.1.2? 
----------------------------

Simpler code and run faster

Many things is cut from the source, like ascenders, augmentGrammar, but the parser can run faster now( profileParse.py run in 0.99s).

Precedency is processed and pass all tests.

----------------------------
What's new in 0.1.1?
----------------------------

# Released date: 2007.5

Big refactor of the code: remove many stuffs: such as ascenderRuleses, descenderRuleses, firstSegments, lastSegments, beforeSegments, followSegments, MinimizeSegments?, fitFollowBefore etc. All tests which is neccessary to parse passed, including precedence tests. The program runs faster now.
